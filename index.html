<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Leaflet Interactive Map</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"
  />
  <style>
    #map {
      height: 90vh;
      width: 100%;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px;
    }
    button {
      padding: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: #007bff;
      color: white;
    }
    button:hover {
      background-color: #0056b3;
    }
    .selected-shape {
      outline: 2px solid yellow;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <button id="drawCircle">Draw Circle</button>
    <button id="drawRectangle">Draw Rectangle</button>
    <button id="shadeDirection">Shade Cardinal Direction</button>
    <button id="selectShape">Select Shape</button>
    <button id="deleteSelectedShape">Delete Selected Shape</button>
    <button id="clearShapes">Clear All Shapes</button>
    <button id="toggleShading">Toggle Shading: Outside</button>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <script>
    let map = L.map("map").setView([37.7749, -122.4194], 13);
    let shapes = [];
    let selectedShape = null;
    let shadeOption = "outside";

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    function getUserLocation(callback) {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition((position) => {
          callback([position.coords.latitude, position.coords.longitude]);
        }, () => {
          alert("Geolocation failed. Using default SF location.");
          callback([37.7749, -122.4194]);
        });
      } else {
        alert("Geolocation not supported.");
        callback([37.7749, -122.4194]);
      }
    }

    document.getElementById("drawCircle").onclick = () => {
      getUserLocation((latlng) => {
        const radius = parseFloat(prompt("Enter radius in meters:"));
        if (isNaN(radius) || radius <= 0) {
          alert("Invalid radius");
          return;
        }
        const circle = L.circle(latlng, {
          radius: radius,
          color: "black",
          fillColor: shadeOption === "inside" ? "red" : "transparent",
          fillOpacity: 0.35,
          draggable: true
        }).addTo(map);
        shapes.push(circle);
      });
    };

    document.getElementById("drawRectangle").onclick = () => {
      alert("Click and drag on the map to draw a rectangle.");
      const drawControl = new L.Draw.Rectangle(map);
      drawControl.enable();
      map.once("draw:created", function (e) {
        const rect = e.layer;
        rect.setStyle({
          fillColor: shadeOption === "inside" ? "red" : "transparent",
          fillOpacity: 0.35,
          color: "black"
        });
        rect.addTo(map);
        shapes.push(rect);
      });
    };

    document.getElementById("shadeDirection").onclick = () => {
      const dir = prompt("Enter N, S, E, or W:").toUpperCase();
      if (!["N", "S", "E", "W"].includes(dir)) {
        alert("Invalid direction!");
        return;
      }

      getUserLocation((latlng) => {
        const delta = 0.01;
        const [lat, lng] = latlng;
        let bounds;

        switch (dir) {
          case "N":
            bounds = [[lat, lng - 0.01], [lat + delta, lng + 0.01]];
            break;
          case "S":
            bounds = [[lat - delta, lng - 0.01], [lat, lng + 0.01]];
            break;
          case "E":
            bounds = [[lat - 0.01, lng], [lat + 0.01, lng + delta]];
            break;
          case "W":
            bounds = [[lat - 0.01, lng - delta], [lat + 0.01, lng]];
            break;
        }

        const rect = L.rectangle(bounds, {
          fillColor: "red",
          fillOpacity: 0.35,
          color: "black"
        }).addTo(map);
        shapes.push(rect);
      });
    };

    document.getElementById("selectShape").onclick = () => {
      alert("Click on a shape to select it.");
      shapes.forEach((shape) => {
        shape.on("click", () => {
          if (selectedShape) {
            selectedShape.setStyle({ color: "black" });
          }
          selectedShape = shape;
          shape.setStyle({ color: "yellow" });
        });
      });
    };

    document.getElementById("deleteSelectedShape").onclick = () => {
      if (selectedShape) {
        map.removeLayer(selectedShape);
        shapes = shapes.filter((s) => s !== selectedShape);
        selectedShape = null;
      } else {
        alert("No shape selected.");
      }
    };

    document.getElementById("clearShapes").onclick = () => {
      shapes.forEach((shape) => map.removeLayer(shape));
      shapes = [];
      selectedShape = null;
    };

    document.getElementById("toggleShading").onclick = (e) => {
      shadeOption = shadeOption === "outside" ? "inside" : "outside";
      e.target.innerText = `Toggle Shading: ${shadeOption.charAt(0).toUpperCase() + shadeOption.slice(1)}`;
    };
  </script>
</body>
</html>
